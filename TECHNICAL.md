프로젝트를 진행하던 중, 말로만 듣던 ‘동시성 문제’를 만났다. 말로만 들어봤지 직접 경험한 건 처음이라 신기했다.  직접 경험해보니 신기해서 재밌긴 했는데… 정말 문제는 따로 있었다. 겪어본 적이 없기 때문에 공부한 적이 없는 분야였다. 공부한 적이 없는 분야다보니 아는 것이 하나도 없었고, 다른 크루들이 제시해주는 해결법의 절반도 못 알아듣는 사태가 발생했다.

이렇게 된거 기초를 한 번 공부해보기로 했다. 아무것도 모르는 것보단 기초를 알고 있는 편이 해결법을 찾기 훨씬 편할테니까. 이 글이 동시성 문제를 발견은 했으나 해결법에 다가가기 힘든 사람들에게도 도움이 될 수 있길 바란다. 해결책에 대해 자세히 알아보기 보다는 해결법을 생각해내기 위한 키워드를 알아보는 글이 될 것이다.

## **동시성 문제란 무엇인가?**

동시성 문제는 한 개의 공유 자원에 여러 개의 스레드가 동시에 접근할 때 발생하는 문제다. 동시성 문제에도 여러 종류가 있다. 한 가지 자원을 여러 스레드가 동시에 접근하려고 할 때 무한 대기 상태에 빠지는 데드락, 동시에 공유 자원에 접근하고 수정하는 순서에 따라 예상치 못한 결과가 발생하는 데이터 레이스, 작업의 진전 없이 스레드끼리 양보상태가 반복되는 라이브 락등이 있다.

그 중에서도 이번에 마주쳤던 문제고 앞으로도 자주 마주칠 문제는 바로 데이터 레이스(Data Race)다. 데이터 레이스란, 동시에 공유 자원에 접근해 일을 수행하는데 일의 진행 순서가 보장되지 않아 예상치 못한 결과가 나오는 현상이다. [오라클 공식문서](https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html)에서는 다음과 같이 설명하고 있다.

```
two or more threads in a single process access the same memory location concurrently, and at least one of the accesses is for writing, and the threads are not using any exclusive locks to control their accesses to that memory.
```

이번 글에서 다루게 되는 동시성 문제는 바로 이 데이터 레이스다. 따라서 이후 작성되는 글은 데이터 레이스 기준이며, 다른 동시성 문제의 해결 키워드에는 적합하지 않을 수도 있다.

### **동시성 문제가 발생하는 이유**

여러 스레드가 동일 자원에 접근하는게 왜 문제가 될까? 공유 자원에 대한 여러 작업에 대해 충돌이 발생하면서 데이터의 정합성이 깨질 수 있기 때문이다.

그렇다면 공유 자원은 무엇인가? 공유 자원(shared resource)의 [사전적 의미](https://en.wikipedia.org/wiki/Shared_resource)는 한 개의 호스트 혹은 네트워크가 이용 가능한 컴퓨터 자원이라고 한다. 즉, 다른 컴퓨터가 로컬에 존재하는 자원처럼 원격으로 접근할 수 있는 자원이다. 우리가 이번 상황에서 고려할 공유 자원은 DB에 저장되어 여러 어플리케이션, 여러 스레드가 동시에 접근할 수 있는 데이터이다.

공유 자원에 동시에 접근한다고 어떤 충돌이 발생하는지 감이 잘 안잡힐 수 있으니 예시를 한 번 들어보자. 여러 명의 관리자가 재고 관리 시스템을 이용해 볶음밥을 파는 시나리오를 가정해보자. 이때 공유 자원은 판매 중인 볶음밥의 재고다. 그리고 각 관리자는 개별의 스레드이다.

![image](https://github.com/user-attachments/assets/9c51e62f-465d-431f-a0aa-f55598ad3e09)

1. 현재 상황에서 시스템에 등록된 볶음밥의 재고는 5개다.
2. A 관리자가 볶음밥의 재고가 5개임을 확인한다. 동시에 B 관리자도 볶음밥의 재고가 5개임을 확인한다.
3. 이때 각각의 관리자가 볶음밥 판매 요청을 처리한다.
4. A 관리자는 볶음밥의 재고가 5개라고 알고있고, 한 개를 판매했으므로 볶음밥의 재고를 4로 변경한다.
5. B 관리자도 볶음밥의 재고가 5개라고 알고있고, 한 개를 판매했으므로 볶음밥의 재고를 4로 변경한다.
6. 두 관리자에게 각각 판매 요청이 들어왔으므로 총 팔린 볶음밥의 개수는 2이다.

   따라서 현재 재고는 3이어야 한다.

   그러나 각 관리자가 4개로 업데이트 했으므로 최종적인 재고가 4개 되고 데이터 부정합이 발생한다.


볶음밥 판매의 결과를 보면 여러 관리자가 동시에 판매를 했기 때문에 충돌이 발생했다. 결과적으로 3이어야 했던 최종적인 데이터가 4가 됐고 데이터의 정합성이 깨져버렸다.

이런 식으로 동기화가 제대로 이뤄지지 않는 상황에서 공유 자원에 접근해 수정을 가하려고 하면 문제가 발생하는 것이다.

### **실제 프로젝트에서 발생했던 동시성 문제**

위의 예시는 흔한 예제이기 때문에 추상적으로 느껴질 수도 있다. 그래서 실제로 프로젝트를 진행하며 겪었던 문제를 하나 더 이야기하려고 한다.

문제 설명 전 프로젝트에 대한 사전 설명을 하겠다. 현재 진행 중인 프로젝트는 다녀온 여행을 기록할 수 있는 여행 기록 서비스다. 이때 기록에 사용하는 여행 장소를 한 가지 테이블(Place 테이블)에서 관리한다. 그리고 이 장소는 여러 여행에서 등장할 수 있으므로 한 번 등록된 장소는 여러 번 등록하지 않고 이미 생긴걸 재사용하려고 한다.

이런 상황에서 위에 설명한 볶음밥과 비슷한 현상이 일어났다. 아래는 문제가 발생한 코드다.

```java
private Place getPlace(TraveloguePlaceRequest request) {
    return placeRepository.findByNameAndLatitudeAndLongitude(
            request.placeName(),
            request.position().lat(),
            request.position().lng()
    ).orElseGet(() -> placeRepository.save(request.toPlace()));
}
```

사용자에게 여행 기록 요청이 들어오면 1차적으로 해당 장소가 존재하는지 확인한다. 만약 확인 후 없다면, 해당 장소를 DB에 새로 추가한다. 이렇게 코드를 작성했으니 `Place` 테이블에는 중복되는 장소가 없을 것이라 생각했고 여행기를 조회할 때는 아래처럼 조회 쿼리에 대한 결과 값이 단일 값이 되는 JPA Query Method를 만들어 사용했다.

```java
Optional<Place> place = placeRepository.findByNameAndLatitudeAndLongitude();
```

아무 문제없이 잘 동작하던 어느 날, QA를 진행하다 갑자기 여행기 조회가 불가능한 오류가 발생했다. 오류가 날만한 부분도 없는 간단한 코드인데 잘 동작하다가 갑자기 오류가 발생하다니! 그것도 특정한 여행기만? 그렇다. 우리의 여행 장소가 볶음밥이 됐다.

에러 로그를 확인해보니, `findByNameAndLatitudeAndLongitude`의 결과 값은 한 개여야 하는데 여러 값이 나온다는 메시지가 찍혀있었다. 분명히 있는지 확인한 후 없으면 값을 넣도록 설계했는데 어떻게 여러 값이 한 번에 들어갔다는걸까?

위에서 설명했던 데이터 레이스가 기억난다면 바로 정답을 유추할 수 있다. 어떤 상황이 벌어졌는지 순차적으로 확인해보자.

![image](https://github.com/user-attachments/assets/010deeb6-81d4-4d8d-828b-26deba733f38)

1. 두 명의 사용자가 동시에 ‘잠실역’이라는 장소를 등록하려고 한다. 이때 각 사용자가 등록하려는 ‘잠실역’이라는 데이터는 위도, 경도, 장소명이 동일하다.
2. 현재 DB에는 ‘잠실역’의 장소 정보가 없는 상황이다.
3. 두 명의 사용자에 대한 요청을 처리하기 위해 두 개의 스레드가 동시에 실행 중이고 각각 DB에 ‘잠실역’이 존재하는지 확인한다.
4. A, B 스레드 모두 ‘잠실역’이 없다는 확인을 받아 생성을 시도한다.
5. 두 스레드의 생성 실행이 모두 완료되어 ‘잠실역’에 대한 레코드가 두 개 생성된다.
6. 이후 조회 시도 시 테이블에는 값이 두 개 들어가 있기 때문에 단일 결과 값이 아닌 2개의 결과가 나오게 된다.

### 어떻게 해결할 수 있을까

동시성 문제로 발생한 예상치 못한 결과가 서비스를 아예 망가트리는 상황을 목격하니 빨리 고쳐야 하는 문제임이 실감날 것이다.

그렇다면 이렇게 데이터 레이스로 발생한 동시성 문제를 어떻게 해결할 수 있을까? 아마 여러 방법이 있을텐데 어떤 키워드가 있는지 감이 잘 안잡힐 것이다. 동시성 문제 해결을 위한 시도는 크게 두 가지 레벨로 나눠볼 수 있다. 현재 Spring boot 프레임워크로 작성된 어플리케이션이니 어플리케이션 코드 단에서 막을 수 있는 방법이 있을 것이다. 그리고 DB에 저장되는 값을 처리하는 과정에서 발생한 문제이니 DB단에서도 처리 방법이 있을 것이다.

이제부터 이제부터 어플리케이션 레벨과 DB 레벨에 대한 해결책을 알아보자.

## **Java 어플리케이션 레벨에서 해결하기**

먼저 Java 어플리케이션 레벨에서 해결하는 분류에 대해 알아보자. Spring boot 어플리케이션에서는 DB의 한 row를 엔티티 객체로 만들어서 사용하고, 이 엔티티 객체가 바로 동시성 문제가 발생할 수 있는 공유 자원이 된다. 여러 스레드가 한 개의 엔티티 객체에 대해 접근해 수정을 가하려고 할 때 데이터 레이스가 발생할 수 있다.

### **동기화 메커니즘**

Java 어플리케이션 레벨에서는 공유 자원을 보호하는 방법으로는 동기화 메커니즘이 존재한다. 한 스레드가 진행 중인 작업에 대해 다른 스레드가 간섭하지 못하도록 막는 스레드 동기화 기능이다. 공유 자원을 사용하는 코드를 임계 영역으로 설정한 후 공유 자원의 락을 획득한 스레드만 해당 임계 영역의 코드를 실행할 수 있도록 방어한다. 이후 락이 반납되어야만 다른 스레드가 임계 영역에 접근해 실행할 수 있다.

그럼 현재 제공되고 있는 동기화 메커니즘은 어떤 것이 있는지 한 번 알아보자.

### **synchronized**

Java에서 스레드 동기화를 할 수 있는 방법 중 첫 번째는 Synchronized 키워드를 사용해 임계 영역을 설정하는 것이다. synchronized 키워드는 두 가지 방식으로 임계 영역을 설정할 수 있다.

1. 메서드 전체 블록 임계 영역 설정

    ```java
    public synchronized void test() {
    	// 임계 영역
    }
    ```

   메서드 전체가 임계 영역으로 지정되면 synchronized 메서드가 호출된 시점부터 내부에 포함된 공유 자원 객체의 락을 얻어 작업을 수행한다. 이후 메서드 종료 시 객체의 락이 반환되면 다른 스레드가 락을 획득할 수 있는 기회를 얻게 된다.

2. 특정 블록 임계 영역 설정

    ```java
    public void test() {
    	// do something
    	synchronized (참조 변수) { // Lock을 획득하고자 하는 공유 자원의 참조 변수
    		// 임계 영역
    	}
    	// do something
    }
    ```

   특정 블록을 임계 영역으로 지정하게 되면 진입 시 지정해둔 참조 변수에 대한 락을 획득하게 된다. 이후 작업이 끝나 블록을 벗어나면 락이 반납되고 다른 스레드에게 락 획득의 기회가 제공된다.


Synchronized 키워드는 사용법이 매우 간단하다. 공유 자원의 Lock 획득과 반납이 자동으로 이뤄지기 때문에 따로 신경써야 할 부분도 없다. 한 가지 주의할 점은 한 스레드가 락을 얻어 임계 영역을 실행 중일 때는 다른 스레드가 대기 상태에 돌입하기 때문에 성능에 영향을 줄 수 있다는 것이다. 따라서 임계 영역을 최소화 하기 위해 고려해볼 필요는 있다.

Synchronized의 동작 원리도 간단히 키워드만 짚어보자. Java의 Synchronized 키워드는 Monitor 방식을 이용한다. 모니터는 세마포어 방식의 단점을 극복하기 위해 등장한 프로그래밍 언어 수준에서 제공되는 상호 배제 방식이다. 보다 더 자세한 내용은 세마포어, 모니터에 대한 키워드를 학습해보길 추천한다.

간단하고 편해보이는 Synchronized에도 단점이 있다. 바로 특정 메서드 혹은 블럭 전체에 락이 걸리고 각 락에 대한 세밀한 제어가 불가능하다는 것이다. 이런 단점을 해결할 수 있는 두 번째 동기화 메커니즘을 소개한다.

### **Lock 인터페이스**

Java는 Lock 인터페이스를 사용한 동기화 메커니즘도 제공한다. 해당 인터페이스의 구현체를 사용하면 락을 세밀하게 조절할 수 있다. 락의 종류를 변경해 생성할 수도 있고 락의 시작과 끝을 직접 명시해 하나의 메서드에 국한되지 않고 여러 메서드에 관통되는 락을 잡을 수도 있다.

Lock 인터페이스의 구현체로는 ReentrantLock, ReentrantReadWriteLock, StampedLock 총 세 가지가 존재한다. 그 중 ReentrantLock이 가장 대표적인 구현체이므로 ReentrantLock으로 사용법을 알아보자.

```java
public void test() {
	Lock lock = new ReenterantLock();

	lock.lock();
	try {
		// crtical section
	} finally {
		lock.unlock();
	}
}
```

위의 코드처럼 락의 시작과 끝을 직접 명시해 임계 영역을 설정할 수 있다. Lock 인터페이스를 활용하면 한 블록이 끝나면 락이 자동으로 반납되던 synchronized와는 달리 락이 끝나는 시점을 직접 명시해야 한다. 예외 처리가 발생하거나 분기문 등에 의해 메서드가 lock 해제 문법 도달 전에 종료될 수 있으므로 보통 `try-finally` 블록을 사용해 락이 무조건 반환될 수 있게 처리한다.

Lock 인터페이스를 사용하면 락 획득을 위한 대기 시간에 타임 아웃을 걸 수 있다. 이를 통해 교착 상태를 방지할 수도 있으며, synchronized 키워드보다 유연한 락 생성 및 해제로 개발자가 직접 관리할 수 있다는 장점이 있다.

### synchronized vs Lock 인터페이스

Java가 제공하는 대표적인 동기화 메커니즘 두 가지를 알아봤다. 둘 다 락을 획득하고 반납함으로써 다른 스레드의 간섭을 막을 수 있는데 두 개의 차이점은 무엇이 있을까?

가장 큰 차이점은 락의 명시 방법이다. synchronized는 자동으로 락을 획득하고 반납하는 반면, Lock 인터페이스는 사용자가 직접 lock을 걸고 반납하는 코드를 명시해야 한다.

추가적으로 synchronized는 락 획득 대기 상태에서의 타임 아웃을 걸 수 없는 반면 Lock 인터페이스는 걸 수 있다는 점, synchronized에서는 사용하지 않는 비공정 락을 Lock 인터페이스에서는 설정할 수 있도록 제공한다는 점 등의 차이가 존재한다.

간단하고 직관적인 사용법을 제공하지만 락에 대한 세밀한 제어가 불가능한 synchronized와 사용법이 다소 복잡하지만 원하는 제어가 가능한 Lock 인터페이스 중 어느 것을 선택할지는 프로젝트의 성질에 따라 잘 고려해보면 좋을 것이다.

## **DB 레벨에서 해결하기**

다음은 DB 레벨에서 해결할 수 있는 법을 알아보자. Java 레벨에서는 DB의 row 정보를 객체로 만든 Entity가 공유 자원이 될거라고 얘기했다. DB 레벨에서는 DB row 자체가 바로 공유 자원이 된다. 여러 개의 DB 트랜잭션이 동시에 동일 row에 대한 수정을 가하려고 할 때 데이터 레이스가 일어난다.

그렇다면 이 트랜잭션간의 간섭으로 인한 데이터 레이스는 어떻게 해결할 수 있을까? MySQL DBMS를 기반으로 DB 레벨 동시성 제어 기법을 알아보자.

### **트랜잭션 격리 수준**

먼저 트랜잭션이 어떻게 서로 간섭하는지 알기 위해 트랜잭션의 격리 수준을 알아야 한다. 트랜잭션이 어떤 격리 수준을 갖느냐에 따라 동시성 문제가 발생할 확률이 달라진다.

트랜잭션 격리 수준은 대표적으로 네 가지가 있다.

1. READ UNCOMMITTED: 트랜잭션 변경 내용이 COMMIT, ROLLBACK 된 것과 상관 없이 다른 트랜잭션이 작업한 내용을 조회할 수 있다.
2. READ COMMITTED: 다른 트랜잭션이 COMMIT한 변경 내용만 조회할 수 있다. 단, 하나의 트랜잭션에서 두 번의 조회가 일어날 때 다른 값을 읽어오는 NON-REPEATABLE READ가 발생할 수 있다.
3. REPETABLE READ: READ COMMITTED처럼 다른 트랜잭션이 COMMIT한 변경 내용만 조회할 수 있다. 대신 다른 트랜잭션의 변경 값에 영향을 받지 않기 위해 트랜잭션 시작 시 Undo 영역에 백업된 데이터를 이용해 동일 트랜잭션 내의 동일 결과를 보장한다.
4. SREALIZABLE: 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없도록 읽기 작업까지 락을 사용한다.

위의 네 가지 중 어떤 트랜잭션 격리 수준을 선택하냐에 따라 데이터 레이스가 일어나게 될 수 있고 데이터의 일관성과 무결성이 깨지게 된다. SREALIZABLE 수준을 사용하면 데이터 레이스가 발생활 확률이 줄어든다. 하지만 일반적으로 SREALIZABLE을 사용하면 동시성 문제는 발생하지 않지만 동시 처리 성능이 떨어져 잘 선택하지 않는다. 동시 처리 성능을 지키기 위해 READ COMMITTED, REPEATABLE READ 방식을 사용하게 된다. 트랜잭션을 완벽히 격리하지 않는 상황에서도 동시성을 제어할 수 있다.

### **동시성 제어 기법**

트랜잭션의 격리 수준으로 인해 데이터 정합성이 깨지는 경우를 방지하기 위해선 동시성 제어(Concurrency Control) 기법을 사용해볼 수 있다. 동시성 제어 기법 중 대표적으로 소개되는건 Lock Based Protocols, Timestamp Based Protocols, Validation Based Protocols 등이 있다.

그 중에서도 DB의 락을 활용하는 Lock Based Protocol의 키워드를 자세히 알아보자.

### Lock Based Protocol

먼저 락이 무엇일까? DB에서의 락은 하나의 트랜잭션이 작업 중인 특정 데이터 항목에 대해 다른 트랜잭션이 접근할 수 없도록 데이터를 잠구는 것이다. Lock Based Protocol은 이 락을 활용해 동시성을 제어한다. 공유 락(S락)과 배타 락(X락)을 사용해 여러 트랜잭션이 접근해 정합성이 깨지는 것을 방지하고 보호하는 것이다.

공유 락은 읽기 작업을 위한 락으로 여러 트랜잭션이 획득할 수 있는 락이다. 배타 락은 쓰기 작업을 위한 락으로 단 한 개의 트랜잭션만 락을 획득할 수 있다. 즉, 한 개의 트랜잭션이 배타 락을 획득해 쓰기 작업을 진행 중이라면 다른 트랜잭션은 공유 락, 배타 락 중 어느 것도 획득할 수 없다. 만약 읽기 락이 여러 개 사용 중인 상황에서 배타 락을 걸고 싶다면 읽기 락이 모두 반납될 때까지 대기 후 배타 락을 시도한다.

|  | S-lock 요청 | X-lock 요청 |
| --- | --- | --- |
| S-lock 보유 | 허용 | 거부 |
| X-lock 보유 | 거부 | 거부 |

다음과 같은 락 호환성을 갖게 되고, 이를 통해 여러 트랜잭션이 동시에 쓰기 작업을 할 수 없도록 방지한다. 여러 트랜잭션이 하나의 row에 대해 동시 쓰기 작업이 불가능하니 공유 자원에 대해 동시에 수정이 발생하는 데이터 레이스 문제도 해결할 수 있다.

## 마무리

여기까지 동시성 문제가 무엇인지에 대해 알아봤다. 그리고 그 해결법을 찾기 위해 필요한 키워드에는 어떤 것이 있는지 알아봤다. 이번 글의 목적은 모든 해결법을 자세히 파헤치는게 아니다. 단지 어떻게 처리할 수 있을지 감도 잡히지 않는 과거의 나같은 사람을 위해 키워드를 제시해주는게 목적이다.

이제 동시성 문제가 발생했다! 데이터 레이스 문제다! 자바 레벨에서 해결할 수 있을까? DB 레벨에서 해결할 수 있을까? 해결하기 위해서는 어떤 키워드 위주로 검색할 수 있을까?에 대해 답할 수 있을 것이다.
