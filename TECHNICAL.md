프로젝트를 진행하던 중, 말로만 듣던 ‘동시성 문제’를 만났다. 말로만 들어보던걸 직접 경험하니 신기해서 재밌긴 했는데… 겪어본 적이 없기 때문에 공부한 적이 없었고, 공부한 적이 없는 분야다 보니 아는 것이 하나도 없어 해결책에 대한 실마리를 잡아낼 수가 없었다.

아무것도 모르는 것보단 기초를 알고 있는 편이 해결법을 찾기 훨씬 편할 테니 기초를 한번 공부해 보자는 마음에서 주제를 선정했다. 이 글이 동시성 문제를 발견은 했으나 해결법에 다가가기 힘든 사람들에게도 도움이 될 수 있길 바란다. 해결책에 대해 자세히 알아보기보다는 실마리를 찾기 위한 키워드를 알아보는 글임을 미리 밝힌다.

# **동시성 문제란 무엇인가?**

동시성 문제는 **한 개의 공유 자원에 여러 개의 스레드가 동시에 접근할 때 발생하는 문제**다.

## 동시성 문제의 종류

동시성 문제에는 여러 종류가 있다. 한 가지 자원을 여러 스레드가 동시에 사용하고자 해 무한 대기 상태에 빠지는 교착상태, 동시에 공유 자원에 접근하고 수정하는 순서에 따라 예상치 못한 결과가 발생하는 데이터 레이스, 작업의 진전 없이 스레드끼리 양보 상태가 반복되는 라이브 락 등이 있다.

그중에서도 이번 글에서 다룰 동시성 문제는 데이터 레이스(Data Race)다. 데이터 레이스란, 동시에 공유 자원에 접근해 일을 수행하는데 일의 진행 순서가 보장되지 않아 예상치 못한 결과가 나오는 현상이다. 이해를 위해 [오라클 공식 문서](https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html)의 설명을 첨부한다.

```
**two or more threads in a single process access the same memory location concurrently, and at least one of the accesses is for writing**, and the threads are not using any exclusive locks to control their accesses to that memory.
```

## 동시성 문제의 발생 원인

동시성 문제는 여러 스레드가 한 개의 공유 자원에 동시에 접근하려고 할 때 발생한다고 설명했다. 공유 자원이 무엇이길래 여러 스레드가 동시에 접근하면 문제를 발생시킬까?

공유 자원(shared resource)의 [사전적 의미](https://en.wikipedia.org/wiki/Shared_resource)는 한 개의 호스트 혹은 네트워크가 이용할 수 있는 컴퓨터 자원이라고 한다. 즉, 다른 컴퓨터가 로컬에 존재하는 자원처럼 원격으로 접근할 수 있는 자원이다. 우리가 이번 상황에서 고려할 공유 자원은 DB에 저장되어 여러 애플리케이션, 여러 스레드가 동시에 접근할 수 있는 데이터이다.

여러 스레드가 동일 자원에 접근하는게 왜 문제가 될까? 공유 자원에 대한 여러 작업에 대해 충돌이 발생하면서 데이터의 정합성이 깨질 수 있기 때문이다. 공유 자원에 여러 작업이 동시에 실행된다고 어떤 정합성이 깨지는지 감이 안잡힐 수 있으니 예시를 살펴보자.

여러 스레드가 동일 자원에 접근하는 게 왜 문제가 될까? 공유 자원에 대한 여러 작업에 대해 충돌이 발생하면서 데이터의 정합성이 깨질 수 있기 때문이다. 공유 자원에 여러 작업이 동시에 실행된다고 어떤 정합성이 깨지는지 감이 안 잡힐 수 있으니 예시를 통해 살펴보자.

여러 명의 관리자가 재고 관리 시스템을 이용해 볶음밥을 파는 시나리오를 가정해 보자. 이때 `공유 자원 == 판매 중인 볶음밥의 재고` , `각 관리자 == 개별의 스레드`가 된다.

![image](https://github.com/user-attachments/assets/9c51e62f-465d-431f-a0aa-f55598ad3e09)

1. 현재 상황에서 시스템에 등록된 볶음밥의 재고는 5개다.
2. A 관리자가 볶음밥의 재고가 5개임을 확인한다. 동시에 B 관리자도 볶음밥의 재고가 5개임을 확인한다.
3. 이때 각각의 관리자가 볶음밥 판매 요청을 처리한다.
4. A 관리자는 볶음밥의 재고가 5개라고 알고 있고, 한 개를 판매했으므로 볶음밥의 재고를 4로 변경한다.
5. B 관리자도 볶음밥의 재고가 5개라고 알고 있고, 한 개를 판매했으므로 볶음밥의 재고를 4로 변경한다.
6. 두 관리자에게 각각 판매 요청이 들어왔으므로 총 팔린 볶음밥의 개수는 2이다.

   따라서 현재 재고는 3이어야 하지만 각 관리자가 4개로 업데이트했으므로 최종적인 재고가 4개 되고 데이터 부정합이 발생한다.


볶음밥 판매의 결과를 보면 여러 관리자가 동시에 판매했기 때문에 충돌이 발생했다. 결과적으로 3이어야 했던 최종적인 데이터가 4가 됐고 데이터의 정합성이 깨져버렸다. 이런 식으로 동기화가 제대로 이뤄지지 않는 상황에서 공유 자원에 접근해 수정을 가하려고 하면 문제가 발생하고 이걸 동시성 문제가 발생한다고 보는 것이다.

## **실제 프로젝트에서의 동시성 문제 발생 사례**

이번에는 실제로 프로젝트를 진행하며 겪었던 문제를 실제 코드와 함께 소개해 보려고 한다. 문제 설명 전 알아둘 프로젝트의 사전 지식은 다음과 같다.

- 현재 진행 중인 프로젝트는 다녀온 여행을 기록할 수 있는 여행 기록 서비스다.
- 이때 기록에 사용하는 여행 장소를 한 가지 테이블(Place 테이블)에서 관리한다.
- 그리고 이 장소는 여러 여행에서 등장할 수 있으므로 한 번 등록된 장소는 여러 번 등록하지 않고 이미 생긴 걸 재사용한다.

이런 상황에서 위에 설명한 볶음밥 현상이 일어났다. 아래는 문제가 발생한 코드다.

```java
private Place getPlace(TraveloguePlaceRequest request) {
    return placeRepository.findByNameAndLatitudeAndLongitude(
            request.placeName(),
            request.position().lat(),
            request.position().lng()
    ).orElseGet(() -> placeRepository.save(request.toPlace()));
}
```

1. 사용자에게 여행 기록 요청이 들어오면 일차적으로 해당 장소가 존재하는지 확인한다.
2. 만약 확인 후 없다면, 해당 장소를 DB에 새로 추가한다.

장소 저장 시 중복 여부를 미리 확인하므로 중복되는 장소가 저장될 리 없을 것이라 예상했고 여행기를 조회할 때는 아래처럼 조회 쿼리에 대한 결괏값이 단일 값이 되는 JPA Query Method를 만들어 사용했다.

```java
Optional<Place> place = placeRepository.findByNameAndLatitudeAndLongitude();
```

아무 문제 없이 잘 동작하던 어느 날, QA를 진행하다 갑자기 여행기 조회가 불가능한 오류가 발생했다. 오류가 날 만한 부분도 없는 간단한 코드인데 잘 동작하다가 갑자기 오류가 발생하다니! 그것도 특정한 여행기만?

그렇다. 우리의 여행 장소가 볶음밥이 됐다. 😵

에러 로그를 확인해 보니, `findByNameAndLatitudeAndLongitude`의 결괏값은 한 개를 기대하는데 여러 값이 반환된다는 메시지가 찍혔다. 분명히 있는지 확인한 후 없으면 값을 넣도록 설계했는데 어떻게 여러 값이 한 번에 들어갔을까?

이 타이밍에서, 위에 설명했던 데이터 레이스가 머리를 스치고 지나간다. 어떤 상황이 벌어졌는지 순차적으로 확인해 보자.

![image](https://github.com/user-attachments/assets/010deeb6-81d4-4d8d-828b-26deba733f38)

1. 두 명의 사용자가 동시에 ‘잠실역’이라는 장소를 등록하려고 한다. 이때 각 사용자가 등록하려는 ‘잠실역’이라는 데이터는 위도, 경도, 장소명이 동일하다.
2. 현재 DB에는 ‘잠실역’의 장소 정보가 없는 상황이다.
3. 두 명의 사용자에 대한 요청을 처리하기 위해 두 개의 스레드가 동시에 실행 중이고 각각 DB에 ‘잠실역’이 존재하는지 확인한다.
4. A, B 스레드 모두 ‘잠실역’이 없다는 확인을 받아 생성을 시도한다.
5. 두 스레드의 생성 실행이 모두 완료되어 ‘잠실역’에 대한 레코드가 두 개 생성된다.
6. 이후 조회 시도 시 테이블에는 값이 두 개 들어가 있기 때문에 단일 결괏값이 아닌 2개의 결과가 나오게 된다.

## 어떻게 해결할 수 있을까

동시성 문제로 인해 발생하는 예상치 못한 결과가 서비스를 동작조차 못 하게 망가트렸다. 빨리 고쳐야 하는데, 어떻게 해결할 수 있을까? 아마 여러 방법이 있을 텐데 어떤 키워드가 있는지 감이 잘 안 잡힐 것이다.

동시성 문제 해결을 위한 시도는 크게 두 가지 레벨로 나눠볼 수 있다.

1. 현재 Spring boot 프레임워크로 작성된 애플리케이션이니 애플리케이션 코드 단에서 막을 수 있는 방법
2. DB에 저장되는 값을 처리하는 과정에서 발생한 문제이니 DB 단에서 처리하는 방법

이제부터 애플리케이션 레벨과 DB 레벨에 대한 해결책을 살펴보자.

# **Java 어플리케이션 레벨에서 해결하기**

Spring boot 애플리케이션에서는 DB의 한 row를 엔티티 객체로 만들어서 사용한다. 그리고 이 엔티티 객체가 동시성 문제 발생 가능성을 보유한 공유 자원이 된다.

즉, **여러 스레드가 한 개의 엔티티 인스턴스에 접근해 수정을 가할 때 데이터 레이스가 발생**할 수 있다.

## **동기화 메커니즘**

Java 애플리케이션 레벨에서는 공유 자원을 보호하는 방법으로는 동기화 메커니즘이 존재한다. 한 스레드가 진행 중인 작업에 대해 다른 스레드가 간섭하지 못하도록 막는 스레드 동기화 기능이다.

동기화 메커니즘은 **공유 자원을 사용하는 코드를 임계 영역으로 설정 후, 공유 자원의 락을 획득한 스레드만 임계 영역의 코드를 실행할 수 있도록 방어**한다. 이후 락이 반납되어야만 다른 스레드가 임계 영역에 접근할 수 있다.

그러면 현재 제공되고 있는 동기화 메커니즘은 어떤 것이 있는지 한 번 알아보자.

### **synchronized**

스레드 동기화 방식 중 첫 번째는 Synchronized 키워드를 사용해 임계 영역을 설정하는 것이다.

synchronized 키워드는 두 가지 방식으로 임계 영역을 설정할 수 있다.

1. 메서드 전체 블록 임계 영역 설정

    ```java
    public synchronized void test() {
    	// 임계 영역
    }
    ```

   메서드 전체가 임계 영역으로 지정되면 synchronized 메서드가 호출된 시점부터 내부에 포함된 공유 자원 객체의 락을 얻어 작업을 수행한다. 이후 메서드 종료 시 객체의 락이 반환되면 다른 스레드가 락을 획득할 수 있는 기회를 얻게 된다.

2. 특정 블록 임계 영역 설정

    ```java
    public void test() {
    	// do something
    	synchronized (참조 변수) { // Lock을 획득하고자 하는 공유 자원의 참조 변수
    		// 임계 영역
    	}
    	// do something
    }
    ```

   특정 블록을 임계 영역으로 지정하게 되면 진입 시 지정해 둔 참조 변수에 대한 락을 획득하게 된다. 이후 작업이 끝나 블록을 벗어나면 락이 반납되고 다른 스레드에 락 획득의 기회가 제공된다.


Synchronized 키워드는 사용법이 매우 간단하다. 공유 자원의 Lock 획득과 반납이 자동으로 이뤄지기 때문에 따로 신경 써야 할 부분도 없다. 한 가지 주의할 점은 한 스레드가 락을 얻어 임계 영역을 실행 중일 때는 다른 스레드가 대기 상태에 돌입하기 때문에 성능에 영향을 줄 수 있다는 것이다. 따라서 임계 영역을 최소화하기 위해 고려해 볼 필요는 있다.

Synchronized의 동작 원리도 간단히 키워드만 짚어보자. Java의 Synchronized 키워드는 Monitor 방식을 이용한다. 모니터는 세마포어 방식의 단점을 극복하기 위해 등장한 프로그래밍 언어 수준에서 제공되는 상호 배제 방식이다. 보다 더 자세한 내용은 세마포어, 모니터에 대한 키워드를 학습해 보길 추천한다.

간단하고 편해 보이는 Synchronized에도 단점이 있다. 바로 특정 메서드 혹은 블록 전체에 락이 걸리고 각 락에 대한 세밀한 제어가 불가능하다는 것이다. 이런 단점을 해결할 수 있는 두 번째 동기화 메커니즘을 소개한다.

### **Lock 인터페이스**

Java는 Lock 인터페이스를 사용한 동기화 메커니즘도 제공한다. 해당 인터페이스의 구현체를 사용하면 락을 세밀하게 조절할 수 있다. 락의 종류를 변경해 생성할 수도 있고 락의 시작과 끝을 직접 명시해 하나의 메서드에 국한되지 않고 여러 메서드에 관통되는 락을 잡을 수도 있다.

Lock 인터페이스의 구현체로는 Reentrant Lock, ReentrantReadWriteLock, Stamped Lock 총 세 가지가 존재한다.

그중 Reentrant Lock이 가장 대표적인 구현체이므로 Reentrant Lock의 사용법을 알아보자.

```java
public void test() {
	Lock lock = new ReenterantLock();

	lock.lock();
	try {
		// crtical section
	} finally {
		lock.unlock();
	}
}
```

위의 코드처럼 락의 시작과 끝을 직접 명시해 임계 영역을 설정할 수 있다.

Lock 인터페이스를 활용하면 한 블록이 끝나면 락이 자동으로 반납되던 synchronized와는 달리 락이 끝나는 시점을 직접 명시해야 한다. 예외 처리가 발생하거나 분기문 등에 의해 메서드가 lock 해제 문법 도달 전에 종료될 수 있으므로 보통 `try-finally` 블록을 사용해 락이 무조건 반환될 수 있게 처리한다.

Lock 인터페이스를 사용하면 락 획득을 위해 대기하는 시간에 타임아웃을 걸어 한계를 정할 수 있다. 이를 통해 교착 상태를 방지할 수도 있으며, synchronized 키워드보다 유연한 락 생성 및 해제로 개발자가 직접 관리할 수 있다는 장점이 있다.

### synchronized vs Lock 인터페이스

Java가 제공하는 대표적인 동기화 메커니즘 두 가지를 알아봤다. 둘 다 락을 획득하고 반납함으로써 다른 스레드의 간섭을 막을 수 있는데 두 개의 차이점은 무엇이 있을까?

가장 큰 차이점은 락의 명시 방법이다. synchronized는 자동으로 락을 획득하고 반납하는 반면, Lock 인터페이스는 사용자가 직접 lock을 걸고 반납하는 코드를 명시해야 한다.

추가로 synchronized는 락 획득 대기 상태에서의 타임아웃을 걸 수 없는 반면 Lock 인터페이스는 걸 수 있다는 점, synchronized에서는 사용하지 않는 비공정 락을 Lock 인터페이스에서는 설정할 수 있도록 제공한다는 점 등의 차이가 존재한다.

간단하고 직관적인 사용법을 제공하지만 락에 대한 세밀한 제어가 불가능한 synchronized와 사용법이 다소 복잡하지만 원하는 제어가 가능한 Lock 인터페이스 중 어느 것을 선택할지는 프로젝트의 성질에 따라 잘 고려해 보면 좋을 것이다.

# **DB 레벨에서 해결하기**

Java 레벨에서는 DB의 row 정보를 객체로 엔티티가 공유 자원이 될 거라고 얘기했다. DB 레벨에서는 DB row 자체가 바로 공유 자원이 된다.

여러 개의 DB 트랜잭션이 동시에 동일 row에 대한 수정을 가하려고 할 때 데이터 레이스가 일어난다. 이를 트랜잭션 간의 간섭이 일어난다고 얘기할 수 있다.

## **트랜잭션 격리 수준**

먼저 트랜잭션이 어떻게 서로 간섭하는지 알기 위해 트랜잭션의 격리 수준을 알아야 한다. 트랜잭션이 어떤 격리 수준을 갖느냐에 따라 발생하는 문제가 달라진다.

트랜잭션 격리 수준은 대표적으로 네 가지가 있다.

1. READ UNCOMMITTED: 트랜잭션 변경 내용이 COMMIT, ROLLBACK 된 것과 상관없이 다른 트랜잭션이 작업한 내용을 조회할 수 있다. 아직 커밋되기 전의 데이터를 읽는 Dirty Read 현상이 발생한다.
2. READ COMMITTED: 다른 트랜잭션이 COMMIT한 변경 내용만 조회할 수 있다. 단, 하나의 트랜잭션에서 두 번의 조회가 일어날 때 다른 값을 읽어오는 NON-REPEATABLE READ가 발생할 수 있다.
3. REPETABLE READ: READ COMMITTED처럼 다른 트랜잭션이 COMMIT한 변경 내용만 조회할 수 있다. 대신 다른 트랜잭션의 변경 값에 영향을 받지 않기 위해 트랜잭션 시작 시 Undo 영역에 백업된 데이터를 이용해 동일 트랜잭션 내의 동일 결과를 보장한다.
4. SREALIZABLE: 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없도록 읽기 작업까지 락을 사용한다.

위의 네 가지 중 어떤 트랜잭션 격리 수준을 선택하는지에 따라 데이터 레이스가 일어나게 될 수 있고 데이터의 일관성과 무결성이 깨지게 된다.

SREALIZABLE 수준을 사용하면 데이터 레이스가 발생할 확률이 줄어든다. 하지만 일반적으로 SREALIZABLE는 동시 처리 성능이 떨어져 잘 선택하지 않는다. 동시 처리 성능을 지키기 위해 READ COMMITTED, REPEATABLE READ 방식을 사용하게 된다.

즉, 트랜잭션을 완벽히 격리하지 않아도 동시성을 제어하는 방법이 필요하다. 그렇다면 이 트랜잭션 간의 간섭으로 인한 데이터 레이스는 어떻게 해결할 수 있을까?

MySQL DBMS를 기반으로 DB 레벨 동시성 제어 기법을 알아보자.

## **동시성 제어 기법**

트랜잭션의 격리 수준으로 인해 데이터 정합성이 깨지는 경우를 방지하기 위해서 동시성 제어(Concurrency Control) 기법을 사용한다. 동시성 제어 기법 중 대표적으로 소개되는 건 Lock Based Protocols, Timestamp Based Protocols, Validation Based Protocols 등이 있다.

그중에서도 DB의 락을 활용하는 Lock Based Protocol의 키워드를 자세히 알아보자.

### Lock Based Protocol

먼저 락이 무엇일까? DB에서의 락은 하나의 트랜잭션이 작업 중인 특정 데이터 항목에 대해 다른 트랜잭션이 접근할 수 없도록 데이터를 잠그는 것이다.

Lock Based Protocol은 이 락을 활용해 동시성을 제어한다. 공유 락(S락)과 배타 락(X락)을 사용해 여러 트랜잭션이 접근해 정합성이 깨지는 것을 방지하고 보호하는 것이다.

공유 락은 읽기 작업을 위한 락으로 여러 트랜잭션이 획득할 수 있는 락이다. 배타 락은 쓰기 작업을 위한 락으로 단 한 개의 트랜잭션만 락을 획득할 수 있다. 즉, **한 개의 트랜잭션이 배타 락을 획득해 쓰기 작업을 진행 중이라면 다른 트랜잭션은 공유 락, 배타 락 중 어느 것도 획득할 수 없다.** 만약 **읽기 락이 여러 개 사용 중인 상황에서 배타 락을 걸고 싶다면 읽기 락이 모두 반납될 때까지 대기 후 배타 락을 시도**한다.

|  | S-lock 요청 | X-lock 요청 |
| --- | --- | --- |
| S-lock 보유 | 허용 | 거부 |
| X-lock 보유 | 거부 | 거부 |

다음과 같은 락 호환성을 갖게 되고, 이를 통해 여러 트랜잭션이 동시에 쓰기 작업을 할 수 없도록 방지한다.

여러 트랜잭션이 하나의 row에 대해 동시 쓰기 작업이 불가능하니 공유 자원에 대해 동시에 수정이 발생하는 데이터 레이스 문제가 해결된다.

## 마무리

여기까지 동시성 문제가 무엇인지에 대해 알아봤다. 그리고 그 해결법을 찾기 위해 필요한 키워드에는 어떤 것이 있는지 알아봤다. 이번 글의 목적은 모든 해결법을 자세히 파헤치는 게 아니다. 단지 어떻게 처리할 수 있을지 감도 잡히지 않는 과거의 나 같은 사람을 위해 키워드를 제시해 주는 게 목적이다.

이제 동시성 문제가 발생했다! 데이터 레이스 문제다! 자바 레벨에서 해결할 수 있을까? DB 레벨에서 해결할 수 있을까? 해결하기 위해서는 어떤 키워드 위주로 검색할 수 있을까에 대해 답할 실마리를 찾을 수 있을 것이다.
